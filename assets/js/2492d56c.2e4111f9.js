"use strict";(self.webpackChunkdevdocs=self.webpackChunkdevdocs||[]).push([[5429],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),i=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=i(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),m=i(n),c=r,k=m["".concat(l,".").concat(c)]||m[c]||d[c]||o;return n?a.createElement(k,s(s({ref:t},u),{},{components:n})):a.createElement(k,s({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var i=2;i<o;i++)s[i]=n[i];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},150:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>i});var a=n(7462),r=(n(7294),n(3905));const o={},s="JSON Querying",p={unversionedId:"guides/propertystore/advanced-querying",id:"guides/propertystore/advanced-querying",title:"JSON Querying",description:"Since Version: 8.5",source:"@site/docs/guides/propertystore/20_advanced-querying.md",sourceDirName:"guides/propertystore",slug:"/guides/propertystore/advanced-querying",permalink:"/docs/guides/propertystore/advanced-querying",draft:!1,editUrl:"https://github.com/pipeforce/pipeforce.github.io/edit/master/docs/guides/propertystore/20_advanced-querying.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Trash Bin",permalink:"/docs/guides/propertystore/trash_bin"},next:{title:"JSON Schema",permalink:"/docs/guides/propertystore/schema-and-objects"}},l={},i=[{value:"Introduction",id:"introduction",level:2},{value:"Property Attributes",id:"property-attributes",level:3},{value:"The <code>select</code> Parameter",id:"the-select-parameter",level:2},{value:"Aggregate Functions",id:"aggregate-functions",level:3},{value:"Convert to JSON",id:"convert-to-json",level:2},{value:"JSON Operators",id:"json-operators",level:2},{value:"Operator <code>-&gt;</code>",id:"operator--",level:3},{value:"Operator <code>-&gt;&gt;</code>",id:"operator---1",level:3},{value:"Operator <code>#&gt;</code>",id:"operator-",level:3},{value:"Operator <code>#&gt;&gt;</code>",id:"operator--1",level:3},{value:"Operator <code>?</code>",id:"operator--2",level:3},{value:"JSON Functions",id:"json-functions",level:2},{value:"<code>to_json</code>",id:"to_json",level:3},{value:"<code>json_array_length</code>",id:"json_array_length",level:3},{value:"<code>json_object_keys</code>",id:"json_object_keys",level:3},{value:"<code>json_strip_nulls</code>",id:"json_strip_nulls",level:3},{value:"<code>json_set</code>",id:"json_set",level:3},{value:"The <code>from</code> Parameter",id:"the-from-parameter",level:2},{value:"The <code>where</code> parameter",id:"the-where-parameter",level:2},{value:"Using <code>LIKE</code>",id:"using-like",level:3},{value:"Using <code>ORDER BY</code>",id:"using-order-by",level:3},{value:"Property Joins",id:"property-joins",level:2},{value:"Merging Join Results",id:"merging-join-results",level:3},{value:"Query Parameters",id:"query-parameters",level:2},{value:"Date and Time Ranges",id:"date-and-time-ranges",level:2},{value:"Report an Issue",id:"report-an-issue",level:2}],u={toc:i};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"json-querying"},"JSON Querying"),(0,r.kt)("p",{class:"theme-doc-version-badge badge badge--secondary"},"Since Version: 8.5"),(0,r.kt)("admonition",{title:"Summary",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"PIPEFORCE allows to query properties very effectively in different ways. In case one of the simple approaches like ",(0,r.kt)("inlineCode",{parentName:"p"},"property.list")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"property.value.get")," is not sufficient for your use case, you can use the command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," which allows for more advanced query options.")),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null," You can create advanced JSON queries using the command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query")),"."),(0,r.kt)("p",null,'This powerful command allows you to create "SQL-style" filters and joins for properties which can be evaluated directly in the database and therefore are in most cases scale much better compared to doing it in memory.'),(0,r.kt)("p",null,"Even if also possible to run queries which are not related to JSON at all, most use-cases are related to JSON documents. Therefore, this will be the focus of these documentation pages."),(0,r.kt)("p",null,"Here is a first example using the command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query")),', which loads "recursively" the value of all properties of the app ',(0,r.kt)("inlineCode",{parentName:"p"},"myapp"),", being a JSON document with attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"title")," having a value which starts with the text ",(0,r.kt)("inlineCode",{parentName:"p"},"Admin")," and converts the final result to a JSON in order to use it in the pipeline for further processing. As you can imagine, this usually becomes a very complex native query since recursive key filtering is combined with JSON path selections, conversions and a LIKE search. The command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," simplifies this a lot for you. The example will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/myapp/**\n      where: |\n        value::json ->> 'title' LIKE 'Admin %'\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"dialect")),": Depending on the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"dialect"),", the command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," can be used with different language implementations. In this example the ",(0,r.kt)("inlineCode",{parentName:"p"},"postgres")," language is used (which is currently the only implementation available). Therefore, you can use most of the native PostgreSQL syntax elements and functions as documented ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"here"),". "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"type")),": If not specified otherwise by the optional parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),", the expected property type is ",(0,r.kt)("inlineCode",{parentName:"p"},"application/json")," by default. So only properties matching this type will automatically be selected for querying. "),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Since in most cases, the ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," command will be used in conjunction with querying JSON documents, if not stated otherwise, all sections below will assume the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," is left out (= set to its default value ",(0,r.kt)("inlineCode",{parentName:"p"},"application/json"),"). ")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"select"),", ",(0,r.kt)("inlineCode",{parentName:"strong"},"from"),", ",(0,r.kt)("inlineCode",{parentName:"strong"},"where")),": These parameters are based on the typical SQL query structure even if their value can differ from the ordinary SQL syntax, based on the selected ",(0,r.kt)("inlineCode",{parentName:"p"},"dialect"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Use the pipe ",(0,r.kt)("inlineCode",{parentName:"p"},"|"),' character for the query parameters for better readability and to avoid quote and tick \'"\\"mixing-hells\\""\'.')),(0,r.kt)("h3",{id:"property-attributes"},"Property Attributes"),(0,r.kt)("p",null,"Keep in mind that a property has multiple property attributes. Each of them can be used in the query:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," - The unqiue key of the property (modifiable)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"uuid")," - The unqiue id of the property (non-modifiable)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - The payload of the property (for example a JSON document)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type")," - The mime type of the payload. (for example ",(0,r.kt)("inlineCode",{parentName:"li"},"application/json"),")."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"created")," -  The timestamp in ms when this property has been created."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updated")," - The timestamp in ms when this property has been changed last."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timeToLive")," - The time to live in minutes of this property.")),(0,r.kt)("p",null,"The attribute which used usually very often, is the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," attribute since it contains the payload of the property. In most cases, it is a JSON document. In order to apply conditions on such a JSON document, you need to convert it to ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," first. See below for further details about this."),(0,r.kt)("h2",{id:"the-select-parameter"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"select")," Parameter"),(0,r.kt)("p",null,"The parmeter ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," of the command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," defines the values, elements or aggregation results to be returned from a property, similar as it is in SQL. The difference to SQL is, that here it is also possible to select and aggregate values from JSON documents in the result set using a ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"special JSON syntax defined by PostgreSQL"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")),(0,r.kt)("p",null,"Return all property values as string of all JSON documents of all apps, recursively:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value\n      from: |\n        global/app/**\n")),(0,r.kt)("p",null,"The result will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "{\\"foo\\":\\"bar\\"}",\n  "{\\"hello\\":\\"world\\"}"\n]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2")),(0,r.kt)("p",null,"Now lets additionally add the property ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," and the property ",(0,r.kt)("inlineCode",{parentName:"p"},"uuid")," to the select condition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        key, uuid, value\n      from: |\n        global/app/**\n")),(0,r.kt)("p",null,"The result will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  [\n    "global/app/myapp/data/foo",\n    "071ab8cb-96d8-47ab-8891-412d93e9751e",\n    "{\\"foo\\":\\"bar\\"}"\n  ],\n  [\n    "global/app/anotherapp/hello",\n    "88e0f953-f85d-4d21-8a86-99be8f82f9e0",\n    "{\\"hello\\":\\"world\\"}"\n  ]\n]\n')),(0,r.kt)("h3",{id:"aggregate-functions"},"Aggregate Functions"),(0,r.kt)("p",null,"Its also possible to use ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-aggregate.html"},"aggregation functions")," like ",(0,r.kt)("inlineCode",{parentName:"p"},"count()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sum()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"avg()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"max()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"min()")," for example in the ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," parameter. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        count(*)\n      from: |\n        global/app/**\n")),(0,r.kt)("p",null,"The result will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"[\n  2\n]\n")),(0,r.kt)("admonition",{title:"Aggregate Functions",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"See the PostgreSQL documentation ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-aggregate.html"},"Aggregate Functions")," for details about all available functions.")),(0,r.kt)("h2",{id:"convert-to-json"},"Convert to JSON"),(0,r.kt)("p",null,"Whenever you would like to do a JSON operation on a value using the ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," command, you need to convert the value to a JSON type first. For this, PostgreSQL provides the data types ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/datatype-json.html"},(0,r.kt)("inlineCode",{parentName:"a"},"json")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"jsonb")),". "),(0,r.kt)("admonition",{title:"Hint",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"While the type ",(0,r.kt)("inlineCode",{parentName:"p"},"json"),' does a "lighweight" conversion to JSON, ',(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," is converting to a more powerful binary JSON version and therefore takes more space and is slower in conversion. At the other hand, some operations are only possible on the ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," type. Additionally, some operations applied on ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," are much faster, because of its optimized format. So it depends on your use-case which one to use. Check the ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"documentation")," which type supports which concrete operation.")),(0,r.kt)("p",null,"The conversion is done by adding the suffix ",(0,r.kt)("inlineCode",{parentName:"p"},"::json")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"::jsonb")," at the end of the value to convert. Some examples of valid conversions are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"value::json\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"value::jsonb\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'\'{"foo":"bar"}\'::json\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'\'{"foo":"bar"}\'::jsonb\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Let's do again an example and output the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," attribute of all JSON properties inside ",(0,r.kt)("inlineCode",{parentName:"p"},"global/app/**"),", but now converted to JSON using the PostgreSQL ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," type: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/**\n")),(0,r.kt)("p",null,"The result will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {"foo":"bar"},\n  {"hello":"world"}\n]\n')),(0,r.kt)("p",null,"As you can see, instead of a JSON string for each result row, a well formatted JSON structure is returned instead. Since the result is a JSON, you can directly use it in the pipeline by subsequent commands, without any additional JSON or Map conversions required:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n\n  # Load it from Property Store\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/**\n\n  # Use the JSON result\n  - log:\n      message: "First item: #{body[0].foo}"\n\n')),(0,r.kt)("p",null,"Now, lets additionally add the property attributes ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"uuid")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        key, uuid, value::json\n      from: |\n        global/app/**\n")),(0,r.kt)("p",null,"The result will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  [\n    "global/app/myapp/data/foo",\n    "071ab8cb-96d8-47ab-8891-412d93e9751e",\n    {"foo":"bar"}\n  ],\n  [\n    "global/app/anotherapp/hello",\n    "88e0f953-f85d-4d21-8a86-99be8f82f9e0",\n    {"hello":"world"}\n  ]\n]\n')),(0,r.kt)("p",null,"As you can see, the text values of the property attributes ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"uuid")," are combined with the JSON object of the value field on each result row. Type conversion to ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," is done by ",(0,r.kt)("inlineCode",{parentName:"p"},"::json")," applied on the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," field. Since the value type is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"application/json")," by default, this can be done without any problem here."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Make sure the field you would like to convert to JSON is a valid JSON document. Otherwise, an error will be thrown. Whenever you store a property using one of the property commands and with the property type set to ",(0,r.kt)("inlineCode",{parentName:"p"},"application/json")," into the property store, the value will be auto-checked whether it is a valid JSON. Therefore, you should always store data into the property store using the property commands.")),(0,r.kt)("h2",{id:"json-operators"},"JSON Operators"),(0,r.kt)("p",null,"After a field was converted to a JSON object using ",(0,r.kt)("inlineCode",{parentName:"p"},"::json")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"::jsonb"),", you can apply JSON operators and functions on it. See the PostgreSQL documentation about ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"JSON Functions and Operations"),"."),(0,r.kt)("p",null,"Let's assume a pattern like ",(0,r.kt)("inlineCode",{parentName:"p"},"globa/app/**")," will return a list of JSON documents like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {"foo":"bar"},\n  {"hello":"world"}\n]\n')),(0,r.kt)("p",null,"Then, here is an example which outputs the value of of the field ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," on any of the selected JSON documents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json -> 'foo'\n      from: |\n        global/app/**\n")),(0,r.kt)("p",null,"This will result in an output like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "bar",\n  null\n]\n')),(0,r.kt)("p",null,"As you can see, the operator ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," is used to select a value from a given JSON result. Only the first JSON has a field ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),". The second doesn't. And therefore ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," is returned here, but no error happened."),(0,r.kt)("p",null,"It the next chapters you will learn more about the most important JSON operators."),(0,r.kt)("h3",{id:"operator--"},"Operator ",(0,r.kt)("inlineCode",{parentName:"h3"},"->")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The JSON operator ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," can be used to select an item from a JSON array (if right part is an int) or an JSON object (if right part is a string). It returns the result as JSON type. Supported on ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," inputs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Select a JSON object and return the result as JSON text."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"firstName\": \"Max\"}'::json -> 'firstName'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"Max"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2")," "),(0,r.kt)("p",null,"Same as Example 1 but with ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"firstName\": \"Max\"}'::jsonb -> 'firstName'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"Max"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3")," "),(0,r.kt)("p",null,"Select a JSON object and return the result as JSON int."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"age\": 38}'::jsonb -> 'age'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"38\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 4")," "),(0,r.kt)("p",null,"Select a JSON array item and return the result as JSON text."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'\'["books", "bikes", "cars"]\'::jsonb -> 0\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"books"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 5")," "),(0,r.kt)("p",null,"Select a JSON array item, nested inside a JSON object and return the result as JSON text."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'\'{\n  "hobbies": ["books", "bikes", "cars"]\n}\'::jsonb -> \'hobbies\' -> 1\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"bikes"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 7")," "),(0,r.kt)("p",null,"Select a JSON array item, nested inside a JSON object and return it as JSON object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'\'{\n  "addresses": [\n    {\n      "street": "Sesame 2",\n      "zipCode": 78321\n    },\n    {\n      "street": "Park Ave 34",\n      "zipCode": 90662 \n    }\n  ]\n}\'::jsonb -> \'addresses\' -> 1\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "street": "Park Ave 34",\n  "zipCode": 90662 \n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 8")," "),(0,r.kt)("p",null,"Select a JSON object item, nested inside a JSON object and return it as JSON object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'\'{\n  "hobbies": ["books", "bikes", "cars"]\n}\'::jsonb -> \'hobbies\'\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'["books", "bikes", "cars"]\n')),(0,r.kt)("h3",{id:"operator---1"},"Operator ",(0,r.kt)("inlineCode",{parentName:"h3"},"->>")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The JSON operator ",(0,r.kt)("inlineCode",{parentName:"p"},"->>")," is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," except that it returns the result always as a string instead of a corresponding JSON type. Supported on ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," inputs."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"This operator is useful in cases where you would like to take the result of the operator and use it in SQL expressions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," for example, since they usually need a primitive type as input.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Select a JSON object and return the result as ordinary string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"firstName\": \"Max\"}'::jsonb ->> 'firstName'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Max\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2")," "),(0,r.kt)("p",null,"Select a JSON object and return the result as string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"age\": 38}'::jsonb ->> 'age'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"38\n")),(0,r.kt)("h3",{id:"operator-"},"Operator ",(0,r.kt)("inlineCode",{parentName:"h3"},"#>")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"->"),", the JSON operator ",(0,r.kt)("inlineCode",{parentName:"p"},"#>")," can be used to select an item from a JSON array or an JSON object by applying a path to it. It returns the result as JSON type. Supported on ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," inputs."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Since the operator ",(0,r.kt)("inlineCode",{parentName:"p"},"#>")," doesn't need evaluation steps, it might be faster than a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," operators. The downside is, that it is harder to read. We suggest to go at first with the variant which is easier to understand for you and optimize later, when really required.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Select a JSON array item, nested inside a JSON object and return it as JSON object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'\'{\n  "addresses": [\n    {\n      "street": "Sesame 2",\n      "zipCode": 78321\n    },\n    {\n      "street": "Park Ave 34",\n      "zipCode": 90662 \n    }\n  ]\n}\'::jsonb #> \'{addresses, 1}\'\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "street": "Park Ave 34",\n  "zipCode": 90662 \n}\n')),(0,r.kt)("h3",{id:"operator--1"},"Operator ",(0,r.kt)("inlineCode",{parentName:"h3"},"#>>")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"This operator is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"#>")," except that it returns the result always as a string. Supported on ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," inputs."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"This operator is useful in case you would like to take the result of the operator and use it in SQL expressions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," for example, since they usually need a primitive type as input.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Select a JSON array item, nested inside a JSON object and return it as string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'\'{\n  "addresses": [\n    {\n      "street": "Sesame 2",\n      "zipCode": 78321\n    },\n    {\n      "street": "Park Ave 34",\n      "zipCode": 90662 \n    }\n  ]\n}\'::jsonb #>> \'{addresses, 1}\'\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\\"street\\": \\"Park Ave 34\\", \\"zipCode\\": 90662}\n')),(0,r.kt)("h3",{id:"operator--2"},"Operator ",(0,r.kt)("inlineCode",{parentName:"h3"},"?")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The operator ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," tests whether a given JSON object contains a key at its top level. It returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Supported only on ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," inputs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Test whether a JSON object contains the given key at current top level."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"firstName\": \"Max\"}'::jsonb ? 'firstName'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"true\n")),(0,r.kt)("p",null,"Now with non-existing key:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"'{\"firstName\": \"Max\"}'::jsonb ? 'foo'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"false\n")),(0,r.kt)("h2",{id:"json-functions"},"JSON Functions"),(0,r.kt)("p",null,"It is also possible to apply functions on ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," converted data.\nSee the official PostgreSQL documentation about ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"JSON Functions and Operations"),"."),(0,r.kt)("h3",{id:"to_json"},(0,r.kt)("inlineCode",{parentName:"h3"},"to_json")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"to_json(data)")," ",(0,r.kt)("inlineCode",{parentName:"p"},"to_jsonb(data)")," try to convert the input ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," into a JSON type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Convert the given text data into a ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"to_jsonb('Hello World!'::text)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"Hello World"\n')),(0,r.kt)("h3",{id:"json_array_length"},(0,r.kt)("inlineCode",{parentName:"h3"},"json_array_length")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"json_array_length(json)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb_array_length(jsonb)")," return the length of the given array."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Return the length of a ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"json_array_length('[0, 1, 2]'::json)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"3\n")),(0,r.kt)("h3",{id:"json_object_keys"},(0,r.kt)("inlineCode",{parentName:"h3"},"json_object_keys")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"json_object_keys(json)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb_object_keys(jsonb)")," return the JSON keys of current level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Return the keys of a ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'json_object_keys(\'{"firstName": "Max", "lastName": "Mayers"}\'::json)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"firstName\nlastName\n")),(0,r.kt)("h3",{id:"json_strip_nulls"},(0,r.kt)("inlineCode",{parentName:"h3"},"json_strip_nulls")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"json_strip_nulls(json)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb_strip_nulls(jsonb)")," strip all fields containg a ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," value. This gets applied only for JSON objects and ",(0,r.kt)("strong",{parentName:"p"},"not")," for JSON arrays."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Remove the the fields with ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," value from ",(0,r.kt)("inlineCode",{parentName:"p"},"jsons")," object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'jsonb_strip_nulls(\'{"firstName": "Max", "lastName": null}\'::jsonb)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"firstName": "Max"}\n')),(0,r.kt)("h3",{id:"json_set"},(0,r.kt)("inlineCode",{parentName:"h3"},"json_set")),(0,r.kt)("p",null,"Also see: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-json.html"},"https://www.postgresql.org/docs/11/functions-json.html")," "),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"json_set(targetjson, path, valuejson, create)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb_set(targetjson, path, valuejson, create)")," set the ",(0,r.kt)("inlineCode",{parentName:"p"},"valuejson")," on a JSON object given by ",(0,r.kt)("inlineCode",{parentName:"p"},"targetjson")," at location defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"path"),". If no entry exists at ",(0,r.kt)("inlineCode",{parentName:"p"},"path"),", creates a new element there in case ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," (default). "),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Make sure that the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"valuejson")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," since this often leads to misunderstandings.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")," "),(0,r.kt)("p",null,"Add a new attribute to a given JSON object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"jsonb_set('{\"firstName\": \"Max\"}'::jsonb, '{lastName}', '\"Meyers\"', true)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"lastName": "Meyers", "firstName": "Max"}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2")," "),(0,r.kt)("p",null,"Add a new attribute to a given JSON object with explicit conversion using ",(0,r.kt)("inlineCode",{parentName:"p"},"to_json"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"jsonb_set('{\"firstName\": \"Max\"}'::jsonb, '{lastName}', to_jsonb('Meyers'::text), true)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"lastName": "Meyers", "firstName": "Max"}\n')),(0,r.kt)("h2",{id:"the-from-parameter"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"from")," Parameter"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," parameter of the command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," defines key patterns of those properties to return for further filtering. It is similar to the SQL ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM"),", but instead of tables, it selects properties. "),(0,r.kt)("p",null,"The key patterns are checked whether the currently executing user has the permission to read from these (sub-) paths."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      from: |\n        global/app/myapp/**\n")),(0,r.kt)("p",null,'This example will return "recursively" all the properties of type ',(0,r.kt)("inlineCode",{parentName:"p"},"application/json")," (= default) inside the app ",(0,r.kt)("inlineCode",{parentName:"p"},"myapp"),"."),(0,r.kt)("p",null,"In case you would like to define multiple patterns, you need to separate them by comma ",(0,r.kt)("inlineCode",{parentName:"p"},",")," and assign each to a variable name using the ",(0,r.kt)("inlineCode",{parentName:"p"},"as")," keyword. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      from: |\n        global/app/myapp/** as a,\n        global/app/anotherapp/** as b\n")),(0,r.kt)("p",null,"The variabe name can be used to reference the patterns later in the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," parameters. "),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        a.value::json\n      from: |\n        global/app/myapp/** as a,\n        global/app/anotherapp/** as b\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"As soon as you have more than one ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," patterns, a join is automatically created for you. And therefore, you need to declare a variable for each pattern using ",(0,r.kt)("inlineCode",{parentName:"p"},"as <variable>"),".")),(0,r.kt)("h2",{id:"the-where-parameter"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"where")," parameter"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," parameter can be used to specify join, filter, group and order conditions for the result, similar to the SQL ",(0,r.kt)("inlineCode",{parentName:"p"},"WHERE")," part."),(0,r.kt)("p",null,"You can use any operation here, the PostgreSQL database supports in the ",(0,r.kt)("inlineCode",{parentName:"p"},"WHERE")," clause. See: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/queries.html"},"https://www.postgresql.org/docs/11/queries.html")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," "),(0,r.kt)("p",null,"Let's assume, we have a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"customer")," JSON documents stored in the Property Store under ",(0,r.kt)("inlineCode",{parentName:"p"},"global/app/myapp/data/customer/<uuid>")," each:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uuid": 2,\n  "firstName": "Max",\n  "lastName": "Meyers",\n  "addressUuid": 12\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uuid": 5,\n  "firstName": "Angelika",\n  "lastName": "Mertens",\n  "addressUuid": 19\n}\n')),(0,r.kt)("p",null,"And now we would like to return only those JSON documents with ",(0,r.kt)("inlineCode",{parentName:"p"},"lastName")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Meyers"),", then we could write this query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/myapp/data/customer/*\n      where: |\n        value::json ->> 'lastName' = 'Meyers'\n")),(0,r.kt)("p",null,"This would return a result like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "uuid": 2,\n    "firstName": "Max",\n    "lastName": "Meyers",\n    "addressUuid": 12\n  }\n]\n')),(0,r.kt)("h3",{id:"using-like"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"LIKE")),(0,r.kt)("p",null,"It is also possible to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," expression combined with JSON queries in the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," parameter. With this expression you can do pattern matching on strings. "),(0,r.kt)("p",null,"See PostgreSQL documentation for more information about ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," expressions: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE"},"https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE")," "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," expression can be applied only on strings, make sure to return the values from JSON documents as such using the ",(0,r.kt)("inlineCode",{parentName:"p"},"->>")," operator, ",(0,r.kt)("strong",{parentName:"p"},"not")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," operator.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Let's assume we would like to rewrite the query from the previous example and return all customers those ",(0,r.kt)("inlineCode",{parentName:"p"},"lastName")," starts with ",(0,r.kt)("inlineCode",{parentName:"p"},"M"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/myapp/data/customer/*\n      where: |\n        value::json ->> 'lastName' LIKE 'M%'\n")),(0,r.kt)("p",null,"The result will be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "uuid": 5,\n    "firstName": "Angelika",\n    "lastName": "Mertens",\n    "addressUuid": 19\n  },\n  {\n    "uuid": 2,\n    "firstName": "Max",\n    "lastName": "Meyers",\n    "addressUuid": 12\n  }\n]\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"LIKE")," expression can be very powerful when it comes in combination with JSON documents.\nBut it can also be quite expensive in terms of performance, depending on the complexity of your query. So keep in mind: Sometimes, it is OK to search in the text version of JSON instead of converting it to ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonb")," first. This could be much faster in certain situations.")),(0,r.kt)("h3",{id:"using-order-by"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"ORDER BY")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ORDER BY")," can be used to sort the result set."),(0,r.kt)("p",null,"See the official PostgreSQL documentation for details about this clause: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/queries-order.html"},"https://www.postgresql.org/docs/11/queries-order.html")," "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Let's assume, we would like to sort the example JSON documents from the previous example by ",(0,r.kt)("inlineCode",{parentName:"p"},"firstName"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/myapp/data/customer/*\n      where: |\n        value::json ->> 'firstName' IS NOT NULL\n        ORDER BY value::json ->> 'firstName' ASC\n")),(0,r.kt)("p",null,"The result will be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "uuid": 5,\n    "firstName": "Angelika",\n    "lastName": "Mertens",\n    "addressUuid": 19\n  },\n  {\n    "uuid": 2,\n    "firstName": "Max",\n    "lastName": "Meyers",\n    "addressUuid": 12\n  }\n]\n')),(0,r.kt)("h2",{id:"property-joins"},"Property Joins"),(0,r.kt)("p",null,"You can also do joins between properties, similar as you would do between multiple tables in SQL."),(0,r.kt)("p",null,"To do so, you need to define the key patterns of the properties you would like to join, each separated by a comma ",(0,r.kt)("inlineCode",{parentName:"p"},",")," and assigned to a variable using the ",(0,r.kt)("inlineCode",{parentName:"p"},"as")," keyword. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      from: |\n        global/app/myapp/** as a,\n        global/app/anotherapp/** as b\n")),(0,r.kt)("p",null,"This example joins all properties matching the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"global/app/myapp/**")," with those, matching ",(0,r.kt)("inlineCode",{parentName:"p"},"global/app/anotherapp/**")," and assigns each to variable names. In the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," clause you can then define the join conditions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")," "),(0,r.kt)("p",null,"Let's assume, we have a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"customer")," entities and ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," with multiple instances stored as JSON in the Property Store, whereas each person has a one to one relatingship to an address entity:"),(0,r.kt)("p",null,"JSON documents stored in property value under ",(0,r.kt)("inlineCode",{parentName:"p"},"global/app/myapp/data/customer/<uuid>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uuid": 2,\n  "firstName": "Max",\n  "lastName": "Meyers",\n  "addressUuid": 12\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uuid": 5,\n  "firstName": "Angelika",\n  "lastName": "Mertens",\n  "addressUuid": 19\n}\n')),(0,r.kt)("p",null,"JSON documents stored in property value under ",(0,r.kt)("inlineCode",{parentName:"p"},"global/app/myapp/data/address/<uuid>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uuid": 12,\n  "street": "Lincoln Blvd",\n  "zipCode": "90001",\n  "city": "Los Angeles"\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uuid": 19,\n  "street": "3 Time Square",\n  "zipCode": "10036-6564",\n  "city": "New York"\n}\n')),(0,r.kt)("p",null,"Now, let's further assume you would like to return all customers living in ",(0,r.kt)("inlineCode",{parentName:"p"},"New York"),". For this you could do a join like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"- property.query:\n    dialect: postgres\n    select: |\n      customer.value::json\n    from: |\n      global/app/myapp/data/customer/* as customer,\n      global/app/myapp/data/address/* as address\n    where: |\n      customer.value::json ->> 'addressUuid' = address.value::json ->> 'uuid' AND\n      address.value::json ->> 'city' = 'New York'\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Note that the values of the JSON fields are compared using the ",(0,r.kt)("inlineCode",{parentName:"p"},"->>")," operator in the join condition since we would like to compare their text value.")),(0,r.kt)("p",null,"This will result in a single output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "uuid": 5,\n    "firstName": "Angelika",\n    "lastName": "Mertens",\n    "addressUuid": 19\n  }\n]\n')),(0,r.kt)("p",null,"You can also return the address document ",(0,r.kt)("strong",{parentName:"p"},"and")," the customer document:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        customer.value::json as a,\n        address.value::json as b\n      from: |\n        global/app/myapp/data/customer/* as customer,\n        global/app/myapp/data/address/* as address\n      where: |\n        customer.value::json ->> 'addressUuid' = address.value::json ->> 'uuid' AND\n        address.value::json ->> 'city' = 'New York'\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},'Note that if you have multiple "result columns" in the ',(0,r.kt)("inlineCode",{parentName:"p"},"select"),' parameter, you need to assign each output "result column" to a unique name using the ',(0,r.kt)("inlineCode",{parentName:"p"},"as")," keyword. The name can be different from the ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," variables. This is currently a known limitation.")),(0,r.kt)("p",null,"This will output the person and the address JSON in each result row: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  [\n    {\n      "uuid": 5,\n      "firstName": "Angelika",\n      "lastName": "Mertens",\n      "addressUuid": 19\n    },\n    {\n      "uuid": 19,\n      "street": "3 Time Square",\n      "zipCode": "10036-6564",\n      "city": "New York"\n    }\n  ]\n]\n')),(0,r.kt)("h3",{id:"merging-join-results"},"Merging Join Results"),(0,r.kt)("p",null,"Sometimes you would like to combine the join results from different JSON properties into a a single JSON. This can be done for example using the ",(0,r.kt)("a",{parentName:"p",href:"#json_set"},(0,r.kt)("inlineCode",{parentName:"a"},"json_set"))," function."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1")),(0,r.kt)("p",null,"In order to merge the result from the example above, you could rewrite the ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," parameter of the query like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n     dialect: postgres\n     select: |\n       jsonb_set(customer.value::jsonb, '{currentAddress}', address.value::jsonb)\n     from: |\n       global/app/myapp/data/customer/* as customer,\n       global/app/myapp/data/address/* as address\n     where: |\n       customer.value::json ->> 'addressUuid' = address.value::json ->> 'uuid' AND\n       address.value::json ->> 'city' = 'New York'\n")),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," parameter we set the address JSON to the customer JSON under new key ",(0,r.kt)("inlineCode",{parentName:"p"},"currentAddress")," which will create a merged JSON as result like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "uuid": 5,\n    "lastName": "Mertens",\n    "firstName": "Angelika",\n    "addressUuid": 19,\n    "currentAddress": {\n      "city": "New York",\n      "uuid": 19,\n      "street": "3 Time Square",\n      "zipCode": "10036-6564"\n    }\n  }\n]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2")),(0,r.kt)("p",null,"You can also merge property attributes outside of the (JSON) value into the resulting JSONs. Let's assume you would like to merge the property attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," as new entry ",(0,r.kt)("inlineCode",{parentName:"p"},"propertyKey")," into the result JSON. For this you could define a query like this: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n     dialect: postgres\n     select: |\n       jsonb_set(customer.value::jsonb, '{propertyKey}', to_jsonb(customer.key))\n     from: |\n       global/app/myapp/data/customer/* as customer,\n       global/app/myapp/data/address/* as address\n     where: |\n       customer.value::json ->> 'addressUuid' = address.value::json ->> 'uuid' AND\n       address.value::json ->> 'city' = 'New York'\n")),(0,r.kt)("p",null,"The result will look like this, then:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "uuid": 5,\n    "lastName": "Mertens",\n    "firstName": "Angelika",\n    "addressUuid": 19,\n    "propertyKey": "/pipeforce/main/global/app/myapp/data/customer/5"\n  }\n]\n')),(0,r.kt)("p",null,"As you can see, an additional field with name ",(0,r.kt)("inlineCode",{parentName:"p"},"propertyKey")," was added and its value was set to the value coming from the property attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"key"),". "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Remember that each property has an attribute structure like this:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "key": "...",\n  "uuid": "...",\n  "type": "...",\n  "value": "...",\n  "timeToLive": 123\n}\n')),(0,r.kt)("p",{parentName:"admonition"},'So you can access each of these fields (called "attributes") also in your queries using their names.')),(0,r.kt)("h2",{id:"query-parameters"},"Query Parameters"),(0,r.kt)("p",null,"The command ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query")),' also supports parameters ("prepared statements") so values coming from users are secured properly.'),(0,r.kt)("p",null,"Here is an example how to define the parameters using the ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - property.query:\n      dialect: postgres\n      select: |\n        value::json\n      from: |\n        global/app/myapp/data/customer/*\n      where: |\n        value::json ->> 'lastName' = :theName\n      params:\n        theName: \"Meyers\"\n")),(0,r.kt)("p",null,"As you can see, the query parameter is defined in the query using ",(0,r.kt)("inlineCode",{parentName:"p"},":theName")," and in ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," the value for it gets assigned."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Since any input coming from the user or external systems has to be treated as a potential security breach, make sure that you put such values in your queries only by using query parameters. Never as string concatenations!")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Using the query parameter inside quotes will not work. So instead of this  "),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"value::json ->> 'lastName' = ':theName'\n")),(0,r.kt)("p",{parentName:"admonition"},"use "),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"value::json ->> 'lastName' = :theName\n"))),(0,r.kt)("h2",{id:"date-and-time-ranges"},"Date and Time Ranges"),(0,r.kt)("p",null,"PostgreSQL offers a huge set of date and time functions and operations: ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/functions-datetime.html"},"https://www.postgresql.org/docs/11/functions-datetime.html"),"."),(0,r.kt)("p",null,"You can use them in the  ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," command."),(0,r.kt)("p",null,"Additionally, PIPEFORCE has many utils, which can help you to create date and time based queries. The most important utils can be found in the ",(0,r.kt)("a",{parentName:"p",href:"../../api/utils#date"},"@date")," util."),(0,r.kt)("p",null,"Below you can find some query examples, how to use these tools with the ",(0,r.kt)("a",{parentName:"p",href:"../../api/commands#propertyquery-v1"},(0,r.kt)("inlineCode",{parentName:"a"},"property.query"))," command."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created today")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created > :beginToday\n      params:\n        beginToday: "#{@date.beginOfDay(0)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created yesterday")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created BETWEEN :beginYesterday AND :beginToday\n      params:\n        beginYesterday: "#{@date.beginOfDay(-1)}"\n        beginToday: "#{@date.beginOfDay(0)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created this week")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created > :beginOfWeek\n      params:\n        beginOfWeek: "#{@date.beginOfWeek(0)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created last week")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created BETWEEN :beginLastWeek AND :beginThisWeek\n      params:\n        beginLastWeek: "#{@date.beginOfWeek(-1)}"\n        beginThisWeek: "#{@date.beginOfWeek(0)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created this month")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created > :beginThisMonth\n      params:\n        beginThisMonth: "#{@date.beginOfMonth(0)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created last month")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created BETWEEN :beginLastMonth AND :beginThisMonth\n      params:\n        beginLastMonth: "#{@date.beginOfMonth(-1)}"\n        beginThisMonth: "#{@date.beginOfMonth(0)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created in the last 6 months")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created > :begin6MonthsBefore\n      params:\n        begin6MonthsBefore: "#{@date.beginOfMonth(-6)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created in the last 12 months")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created > :begin12MonthsBefore\n      params:\n        begin12MonthsBefore: "#{@date.beginOfMonth(-12)}"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Return all properties created last year")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'pipeline:\n  - property.query:\n      select: |\n        *\n      from: |\n        global/**\n      where: |\n        created BETWEEN :beginLastYear AND :beginThisYear\n      params:\n        beginLastYear: "#{@date.beginOfYear(-1)}"\n        beginThisYear: "#{@date.beginOfYear(0)}"\n')),(0,r.kt)("h2",{id:"report-an-issue"},"Report an Issue"),(0,r.kt)("admonition",{title:"Your help is needed!",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In case you're missing something on this page, you found an error or you have an idea for improvement, please ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pipeforce/pipeforce.github.io/issues/new"},"click here to create a new issue"),". Another way to contribute is, to click ",(0,r.kt)("strong",{parentName:"p"},"Edit this page")," below and directly add your changes in GitHub. Many thanks for your contribution in order to improve PIPEFORCE!")))}d.isMDXComponent=!0}}]);